# Likable Codebase - Technical Architecture Overview

## 1. System Overview

Likable is an **AI-powered React + Supabase scaffolding and development framework** that orchestrates three major components:
- **Claude/Gemini AI models** for intelligent code generation
- **Supabase** for local backend development with PostgreSQL and authentication
- **Git** for version control and atomic commits

The system acts as a CLI-based orchestrator that guides users through project creation, initializes a fully configured development environment, and hands off control to an AI assistant (Claude Code or Gemini CLI) to build the application autonomously.

---

## 2. How AI Models (Claude/Gemini) Are Integrated

### 2.1 AI Selection and Installation

**Entry Point**: `src/commands/wizard.ts` → `createProjectWizard()` function

The system supports two AI models:
- **Claude Code**: `@anthropic-ai/claude-code` ($20/month, unlimited requests)
- **Gemini CLI**: `@google/gemini-cli` (Free, 60 req/min)

**Detection Logic** (lines 197-240 in wizard.ts):
1. Check if Claude Code is installed: `checkClaudeCodeInstalled()` → runs `claude --version`
2. Check if Gemini CLI is installed: `checkGeminiInstalled()` → runs `gemini --version`
3. If neither installed, default to Gemini (free option)
4. If both installed, prompt user to choose

**Installation Mechanism**:
- `installClaudeCode()`: Tries global install first, falls back to local project install
- `installGemini()`: Same strategy - global first, then local fallback
- Both use `execa()` to run npm install commands

### 2.2 Launching AI with Permission Modes

**Key Functions**:
- `launchClaudeCode()` (ai-helper.ts lines 214-345)
- `launchGeminiCode()` (ai-helper.ts lines 412-535)

**Permission Modes**:

1. **YOLO Mode** (Auto-Accept):
   - Claude Code: `--permission-mode acceptEdits`
   - Gemini: `--yolo`
   - Result: AI can freely create/modify/delete files without user confirmation

2. **Review Mode** (Default):
   - Claude Code: Default behavior requires user approval per change
   - Gemini: Default behavior requires user approval per change

**Allowed Tools Whitelist** (ai-helper.ts lines 249-262 for Claude):
```typescript
--allowedTools
Bash(npm:*)           // npm package management
Bash(npx:*)           // npx commands
Bash(supabase:*)      // Supabase CLI (if needsSupabase flag set)
Bash(git:*)           // Git version control
Bash(node:*)          // Node.js
Bash(open:*)          // Open browser
Bash(find:*)          // File search
Read                  // Read files
Glob                  // File globbing
Grep                  // Grep searching
```

Similar toolset for Gemini with different syntax (`--allowed-tools bash,read,write,edit,glob,grep,supabase`)

### 2.3 AI Prompting Strategy

**Three Levels of Prompt Content** (ai-context.ts):

1. **CLAUDE.md / GEMINI.md** (Static Context Files):
   - Created for both AIs so users can switch later
   - Contains permission mode, dev server info, project type
   - Instructs AI on mandatory validation workflows (TypeScript checks, build)
   - Includes git commit instructions if git is available
   - Generated by: `writeAIContextMd()` (ai-context.ts lines 196-217)

2. **LIKABLE.md** (Detailed Build Instructions):
   - Project-specific development guide
   - Lists MVP features from SPEC.md
   - Defines 4-phase development workflow:
     - Phase 1: UI Skeleton (components + dummy data, no API)
     - Phase 2: Visual Completeness (styling, loading states)
     - Phase 3: Validation Checkpoint (TypeScript/build checks)
     - Phase 4: Data Integration (real APIs, Supabase)
   - Emphasizes mandatory validation: `npx tsc --noEmit` after every file
   - Git commits mandatory after successful builds
   - Generated by: `writeLikableMd()` (ai-context.ts lines 222-374)

3. **Initial Launch Prompt**:
   - Generated by: `generateAIInitialPrompt()` (ai-context.ts lines 122-191)
   - Instructs AI to:
     1. Start dev server (Claude) or assume it's running (Gemini)
     2. Create SPEC.md with MVP features and UX guidelines
     3. Wait for user approval of spec
     4. Build UI-first (skeleton → visual completeness → data)
     5. Validate at every step

**Prompt Sanitization** (sanitize.ts):
- `sanitizeForCLI()`: Removes ANSI escape codes, control characters, collapses newlines
- `sanitizeForMarkdown()`: Preserves newlines, removes only escape codes
- `sanitizeUserInput()`: General sanitization for all user input

### 2.4 AI Model-Specific Differences

| Feature | Claude Code | Gemini CLI |
|---------|------------|-----------|
| Default port | 13337 (random) | 13337 (random) |
| Dev server | AI starts via `npm run dev` | Pre-started in background |
| Model | Claude 3.5 Sonnet (latest) | gemini-2.5-flash (free) |
| Tool format | `Bash(command:pattern)` | `bash,read,write,edit,glob,grep` |
| Permission mode | `acceptEdits` | `--yolo` |
| Model selection | User choice or auto | `--model gemini-2.5-flash` |

---

## 3. Supabase Integration

### 3.1 Supabase Architecture

**Supabase Setup Flow** (scaffold.ts):
1. Initialize Supabase project: `npx supabase init --yes`
2. Allocate ports (default or alternatives if conflicts)
3. Update config.toml with allocated ports
4. Create Supabase client file (src/lib/supabase.ts)
5. Create .env.local with credentials
6. Start Supabase: `npx supabase start`

### 3.2 Port Management (portManager.ts)

**Default Supabase Ports**:
```typescript
api: 54321      // Kong API Gateway
db: 54322       // PostgreSQL database
studio: 54323   // Supabase Studio UI
inbucket: 54324 // Email testing
analytics: 54327 // Logflare analytics
pooler: 54329   // PgBouncer connection pooler
```

**Port Allocation Strategy**:
- Check if all default ports available via `isPortAvailable()` (tcp socket check)
- If any in-use, find alternative range by jumping 100 ports: 54421, 54521, etc.
- Maximum 50 attempts to find available range
- Updates config.toml with new ports if needed

**Dev Server Port Allocation**:
- Random port between 13337-65535
- Falls back to 13337 if all 50 random attempts fail
- Configured in vite.config.ts

### 3.3 Supabase Client Integration

**Client File Generation** (scaffold.ts lines 246-275):
```typescript
// src/lib/supabase.ts (TypeScript example)
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL || '';
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY || '';

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
```

**Environment Variables** (.env.local):
```
VITE_SUPABASE_URL=http://127.0.0.1:54321
VITE_SUPABASE_ANON_KEY=<generated-key-from-supabase-status>
```

### 3.4 Database Operations

**Service Manager** (services.ts):
- `startSupabase()`: Starts Docker containers via `npx supabase start`
- `stopSupabase()`: Stops containers via `npx supabase stop --no-backup`
- `updateEnvFile()`: Updates .env.local with live credentials
- `extractSupabaseCredentials()`: Parses JSON status output to extract URL and anon key

**Credential Extraction** (services.ts lines 296-351):
- Tries JSON parsing first: `npx supabase status --output json`
- Fallback regex extraction if JSON parsing fails
- Handles multiple field name variations (API_URL, api_url, API URL; ANON_KEY, anonKey, etc.)

**Error Handling**:
- Detects port conflicts: "port is already allocated"
- Offers to stop conflicting Supabase project automatically
- Allows user to skip Supabase and continue with dev server only

### 3.5 Configuration Management

**Config Cleanup** (portManager.ts lines 160-197):
- Removes deprecated `email_optional` key from `[auth.external.apple]`
- Disables analytics: `[analytics] enabled = false`
- Runs before Supabase initialization to prevent startup errors

**Config Updates** (portManager.ts lines 202-257):
- Regex-based updates to supabase/config.toml
- Updates all port references: api, db, studio, inbucket, analytics, pooler
- Uses multiline patterns to avoid matching wrong sections

### 3.6 Database Migrations

**Not yet implemented** - No migration files in codebase (only config setup).

The system:
- Initializes Supabase with `npx supabase init`
- Creates empty migrations folder structure
- Instructs users/AI to create migrations as needed
- Does not auto-generate migrations (AI responsibility)

---

## 4. Git Integration

### 4.1 Git Initialization

**Automatic Setup** (scaffold.ts lines 386-446):

1. Create .gitignore:
   - node_modules/, dist/, build/
   - .env.local and other env files
   - Supabase: .branches, .temp
   - Standard excludes: .DS_Store, *.log, .vscode, .idea

2. Initialize git repo: `git init`
   - Only if git is detected and available
   - Otherwise skipped gracefully

### 4.2 Version Control Workflow Enforcement

**Git Integration in AI Context** (ai-context.ts):

The LIKABLE.md instructions **mandate** git commits as part of validation:

```markdown
**Phase 3 - Validation Checkpoint:**
- MANDATORY: Run `git add .` then `git commit -m "feat: description"`

**Phase 4 - Data Integration:**
- MANDATORY: After completing each feature, run `git add <files>` and `git commit -m "feat: description"`

**Validation includes commits:**
- Never skip git add (step 6)
- Never skip git commit (step 7)
- Skipping commits = validation failure = broken workflow
```

**Conventional Commit Format**:
- `feat:` for new features
- `fix:` for bug fixes
- `refactor:` for refactoring
- `chore:` for chores

### 4.3 Git Status Detection

**Detecting Existing Projects** (wizard.ts lines 54-66):
- Checks for LIKABLE.md in current directory
- If exists: `continueWorkingWizard()` → launches AI for existing project
- If not exists: `createProjectWizard()` → creates new project

**Git Detection** (scaffold.ts lines 365-384):
- Attempts `git --version`
- Returns boolean: `{ docker: boolean; git: boolean }`
- Used to conditionally add git instructions to AI context

---

## 5. Overall Workflow - The Three Components Working Together

### 5.1 Complete Initialization Flow

```
User runs: likable
    ↓
CLI.ts: CLI entrypoint checks for LIKABLE.md
    ├─ Exists → continueWorkingWizard()
    └─ Not exists → createProjectWizard(quickStart, description)
    
createProjectWizard():
    ↓
Step 1: Detect AI (Claude Code / Gemini CLI)
    ├─ checkClaudeCodeInstalled()
    ├─ checkGeminiInstalled()
    └─ Auto-select or prompt user
    
Step 2: Check Prerequisites
    ├─ checkDocker() → required for Supabase
    ├─ checkGit() → optional, enables version control
    └─ Offer installation instructions if missing
    
Step 3: Project Config
    ├─ In quickStart mode: prompt for description → AI generates name
    ├─ In full mode: full prompts for all settings
    └─ Generate using generateProjectName(AI, description)
    
Step 5: Create Project (scaffoldProject):
    ├─ Create directory
    ├─ Initialize Vite + React
    ├─ Update package.json (dependencies based on config)
    ├─ npm install
    ├─ Setup Supabase:
    │   ├─ npx supabase init
    │   ├─ Allocate ports
    │   ├─ Update config.toml with allocated ports
    │   └─ Create supabase client (src/lib/supabase.ts)
    ├─ Setup Tailwind (if selected)
    ├─ Create vite.config.ts with allocated port
    ├─ Create .env.local with Supabase credentials
    ├─ Create project structure (components/, pages/, hooks/, etc.)
    └─ Initialize git repo (if git available)
    
Step 6: Start Services
    ├─ ServiceManager.startSupabase(skipExistingCheck=true)
    │   ├─ Run: npx supabase start --yes
    │   ├─ Run: npx supabase status --output json
    │   ├─ Extract credentials from status JSON
    │   └─ Update .env.local with live credentials
    │
    └─ Gemini only: ServiceManager.startDevServer(background=true, port)
        ├─ Run: npm run dev --port
        └─ Pipe output to dev-server.log
    
Step 7: Write AI Context Files
    ├─ writeAIContextMd('claude', projectPath, config)
    ├─ writeAIContextMd('gemini', projectPath, config)
    └─ writeLikableMd(selectedAI, projectPath, config)
    
Step 8: Launch AI
    ├─ If Claude Code:
    │   └─ launchClaudeCode(projectPath, installType, initialPrompt, autoAccept, features, port)
    │       └─ Run: claude [--permission-mode acceptEdits] [--allowedTools ...] [initialPrompt]
    │           └─ stdio: inherit (interactive)
    │
    └─ If Gemini CLI:
        └─ launchGeminiCode(projectPath, installType, initialPrompt, autoAccept, features, port)
            └─ Run: gemini --model gemini-2.5-flash [--yolo] [--allowed-tools ...] [--prompt-interactive]
                └─ stdio: inherit (interactive)

Step 9: Cleanup
    └─ ServiceManager.stopSupabase()
        └─ Run: npx supabase stop --no-backup
```

### 5.2 AI Development Workflow (Inside Claude/Gemini)

Once AI is launched with initial prompt:

```
Initial Prompt tells AI:
    ↓
1. Create SPEC.md
    └─ Describe MVP features (from user perspective, not technical)
    └─ UI/UX guidelines (modern, lovable, appealing)

2. Display SPEC.md to user for approval
    ├─ Create SpecReview.tsx component
    ├─ Import SPEC.md as raw text: `import specContent from '/SPEC.md?raw'`
    ├─ Render with react-markdown
    ├─ Open browser: `open http://localhost:PORT`
    └─ Wait for user: "approved" or feedback

3. If approved: Build autonomously (no more asking)
    ├─ Phase 1: UI Skeleton
    │   ├─ Create all components
    │   ├─ Use typed dummy data (interfaces match API shapes)
    │   ├─ No API calls or business logic
    │   ├─ After EVERY file:
    │   │   ├─ npx tsc --noEmit (validation)
    │   │   └─ npm run build (build check)
    │   ├─ If Git enabled:
    │   │   └─ git add . && git commit -m "feat: ui-skeleton"
    │   └─ STOP if ANY errors
    │
    ├─ Phase 2: Visual Completeness
    │   ├─ Add Tailwind classes (or library styling)
    │   ├─ Add loading/error/empty states
    │   ├─ Placeholder handlers for interactions
    │   ├─ Run validation after each state added
    │   └─ Commit when done: "feat: add styling and states"
    │
    ├─ Phase 3: Validation Checkpoint
    │   ├─ npx tsc --noEmit (must show ZERO errors)
    │   ├─ npm run build (must succeed)
    │   ├─ If Git: git add . && git commit -m "feat: ui-complete"
    │   └─ Manual test: open browser, test UI flow
    │
    └─ Phase 4: Data Integration
        ├─ Replace dummy data with real API calls
        ├─ Implement Supabase queries (supabase client already configured)
        ├─ Implement event handlers
        ├─ Run validation after each integration
        └─ Commit after each feature: "feat: integrate feature-name"

4. If feedback on SPEC: Update SPEC.md and re-show (Vite HMR auto-refreshes)
    └─ Repeat until approved
```

### 5.3 Data Flow Between Components

```
┌─────────────────────────────────────────────────────────┐
│ User Input                                              │
│ ├─ AI choice (Claude/Gemini)                           │
│ ├─ Project name & description                          │
│ ├─ Features (auth, database, uploads, etc.)            │
│ └─ Component library (shadcn, chakra, mui, none)       │
└──────────────────┬──────────────────────────────────────┘
                   ↓
┌──────────────────────────────────────────────────────────┐
│ Likable CLI Orchestration                               │
│ ├─ Validates prerequisites (Docker, Git, Node.js)      │
│ ├─ Installs/detects AI (Claude Code or Gemini CLI)     │
│ └─ Scaffolds project structure                         │
└──────────────────┬──────────────────────────────────────┘
                   ↓
        ┌──────────┴──────────┐
        ↓                     ↓
┌──────────────────┐  ┌──────────────────┐
│ Supabase Setup   │  │ Git Init         │
│                  │  │                  │
│ 1. Init config   │  │ 1. Create        │
│ 2. Allocate port │  │    .gitignore    │
│ 3. Start Docker  │  │ 2. Init repo     │
│ 4. Extract creds │  │ 3. Track origin  │
│ 5. Update .env   │  │                  │
└─────────┬────────┘  └────────┬─────────┘
          │                    │
          └────────┬───────────┘
                   ↓
        ┌──────────────────────┐
        │ Context Files        │
        │                      │
        │ 1. CLAUDE.md         │
        │ 2. GEMINI.md         │
        │ 3. LIKABLE.md        │
        │ 4. Initial prompt    │
        └──────────┬───────────┘
                   ↓
      ┌────────────────────────┐
      │ AI Launch              │
      │                        │
      │ execa('claude', args)  │
      │    or                  │
      │ execa('gemini', args)  │
      │                        │
      │ Inherits stdio (fully  │
      │ interactive)           │
      └────────────┬───────────┘
                   ↓
        ┌──────────────────────┐
        │ AI Development Loop  │
        │                      │
        │ 1. Create SPEC.md    │
        │ 2. Build UI (phase 1)│
        │ 3. Validate/commit   │
        │ 4. Add styling (p2)  │
        │ 5. Validate/commit   │
        │ 6. Integrate API (p4)│
        │ 7. Validate/commit   │
        │                      │
        │ Access:              │
        │ - Dev server         │
        │ - Supabase client    │
        │ - npm/supabase CLIs  │
        │ - git commands       │
        └──────────┬───────────┘
                   ↓
        ┌──────────────────────┐
        │ AI Exit (SIGINT)     │
        │                      │
        │ Cleanup:             │
        │ - Stop Supabase      │
        │ - Close dev server   │
        │ - Exit gracefully    │
        └──────────────────────┘
```

---

## 6. Key Architectural Patterns

### 6.1 Service Orchestration

**ServiceManager Class** (services.ts):
- Manages lifecycle of Supabase and dev server
- Handles background process management
- Implements graceful shutdown (SIGINT/SIGTERM)
- Logs output to files (dev-server.log)

### 6.2 Subprocess Execution Strategy

**Two stdio modes** (scaffold.ts comment lines 10-18):
- `stdio: 'inherit'` → Interactive commands (permission prompts, Docker auth)
- `stdio: 'pipe'` → Non-interactive commands (version checks, status parsing)

**Process Management**:
- Detached processes for background dev server
- Unref() to allow parent process to exit
- Promise-based error handling with execa()

### 6.3 Configuration as Code

**Immutable Config Generation**:
- vite.config.ts: Generated with allocated port
- supabase/config.toml: Regex-updated with allocated ports
- .env.local: Generated and updated with live credentials
- Prevents manual config errors

### 6.4 Input Sanitization (Defense in Depth)

Applied at multiple levels:
1. **User input from prompts**: `sanitizeUserInput()`
2. **CLI arguments**: `sanitizeForCLI()` (removes newlines)
3. **Markdown files**: `sanitizeForMarkdown()` (preserves formatting)
4. **AI prompts**: Sanitized before passing to claude/gemini CLIs

Prevents:
- ANSI escape code injection
- Control character injection
- Zero-width character obfuscation

### 6.5 Progressive Enhancement

**Feature Detection**:
- Docker optional (skips Supabase)
- Git optional (skips version control instructions)
- Claude Code or Gemini (auto-detects, user can choose)
- Component library (multiple options)

**Graceful Degradation**:
- Continues without Docker → skip Supabase setup
- Continues without Git → skip git init
- Falls back to AI auto-selection if both CLIs installed

---

## 7. Code Organization

### 7.1 Directory Structure

```
src/
├── cli.ts                    # Entry point (CLI setup)
├── index.ts                  # Package exports
├── commands/
│   ├── wizard.ts            # Main interactive wizard (1600+ lines)
│   ├── init.ts              # Direct init command
│   ├── deploy.ts            # Deployment to Vercel
│   └── add-feature.ts       # Stub for future feature templates
└── utils/
    ├── ai-context.ts        # Generate CLAUDE.md, GEMINI.md, LIKABLE.md
    ├── ai-helper.ts         # AI detection, install, launch
    ├── services.ts          # ServiceManager for Supabase/dev server
    ├── scaffold.ts          # Project scaffolding
    ├── portManager.ts       # Port allocation & config management
    ├── prompts.ts           # Inquirer prompts for user input
    ├── sanitize.ts          # Input sanitization utilities
    ├── logger.ts            # Colored logging
    ├── first-run.ts         # Welcome message
    └── constants.ts         # Shared constants
```

### 7.2 Dependency Injection Pattern

No formal DI, but functional composition:
- Services passed as arguments
- Config objects passed through function chains
- Logger as singleton export

### 7.3 Error Handling

**Strategy**:
- Try/catch with logger.error() calls
- User-friendly error messages
- Fallback mechanisms (e.g., regex extraction if JSON parsing fails)
- Graceful continue on non-critical errors

---

## 8. Security Considerations

### 8.1 Input Validation

- Project name: `/^[a-z0-9-]+$/` (alphanumeric + hyphens only)
- Description: Min 10 chars, sanitized for escape codes
- No eval() or code execution of user input
- CLI arguments validated before passing to subprocess

### 8.2 Environment Variables

- `.env.local` created with template
- Credentials from `supabase status` parsed carefully
- No secrets hard-coded in generated code

### 8.3 File System Operations

- `fs.mkdir()` with recursive: true
- No symlink following
- Standard ignore patterns (.gitignore)

### 8.4 Subprocess Safety

- Uses `execa()` (safer than child_process.exec)
- Arguments passed as arrays (not concatenated strings)
- No shell injection vectors
- Explicit stdin/stdout/stderr handling

---

## 9. Performance Characteristics

### 9.1 Installation Time

- Vite init: ~5-10 seconds
- npm install: ~30-60 seconds
- Supabase init: ~5 seconds
- Supabase start (first time): ~60-120 seconds (Docker pull)
- Total new project: ~2-3 minutes first time, ~1-2 minutes subsequent

### 9.2 Memory Usage

- Dev server background process: ~100-200 MB (Vite)
- Supabase containers: ~500 MB - 1 GB (Docker)
- CLI itself: ~50-100 MB

### 9.3 Bottlenecks

- Docker image pulls (network-dependent)
- npm install (network-dependent)
- Supabase initialization (IO-bound)

---

## 10. Extension Points and Future Development

### 10.1 Stubbed Features

- **add-feature.ts**: Empty stub for adding feature templates
- **deploy.ts**: Only Vercel implemented
- No migration generation system
- No database schema generation

### 10.2 Potential Extensions

- AWS/Railway/Render deployment targets
- More component libraries (Ant Design, etc.)
- Feature templates (authentication flow, CRUD, etc.)
- Database schema generator from SPEC
- Post-deployment monitoring

---

## 11. Version History (Recent)

```
0.5.4: Latest (current)
  - Enhanced AI wizard validation with build checks

0.5.3:
  - Flexible Supabase usage instructions

0.5.2:
  - Removed supabase global dependency

0.5.1:
  - Bug fixes for global installation

0.5.0:
  - Major: Random port allocation, Supabase CLI improvements
  - Git commits mandatory in validation workflow

0.4.0:
  - Port manager, SPEC approval workflow, git integration
```

---

## Summary: How It All Works Together

1. **User launches `likable`** → Checks prerequisites and detects AI
2. **Orchestrator scaffolds project** → Initializes Vite, Supabase, Git
3. **Writes context files** → CLAUDE.md, GEMINI.md, LIKABLE.md guide the AI
4. **Launches AI with strict rules**:
   - Auto-accept mode in YOLO
   - Whitelist tools (npm, npx, supabase, git)
   - Inherit stdio for full interactivity
5. **AI builds according to instructions**:
   - Create SPEC.md for user approval
   - Build 4-phase workflow (UI → styling → validation → data)
   - Mandatory validation: TypeScript check + build test
   - Mandatory git commits after successful builds
   - Access to running Supabase via pre-configured client
6. **Cleanup on exit** → Stop Supabase containers

**Key insight**: Likable doesn't auto-generate code. Instead, it **sets up the environment perfectly** and gives clear, mandatory instructions to the AI. The AI is trusted to execute autonomously but must follow strict validation and git workflows.

